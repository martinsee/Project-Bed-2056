---
title: "Untitled"
author: "Martin S. Bjørnerem"
date: "7 desember 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE)
library(tidyverse)
library(readxl)
library(lubridate)
library(mosaic)
library(tsibble)
library(tidyquant)
library(rvest)
```
#Vårt prosjekt:
Overview og problemstilling: Utgangspunkt og endringer i oppgaven
Inspirasjon:
Data:
Kilder:

##Korrelasjonsanalyse

Bitcoin og det amerikanske aksjemarkedet. Vi ser for oss at nordmenn som har investert i bitcoin også har investert i det norske aksjemarkedet. Vi ønsker å undersøke om prisutviklingen på bitcoin påvirker aksjekursene. Vi har hentet daglig data for bitcoin i USD (BTC/USD) og s&p500 så langt bak i tid som mulig. Siden BTC kan kjøpes og selges hele uka, også i helgene, har vi valgt å fjerne observasjoner lørdager og søndager slik at vi kan "matche"" datasettene. En alternativ løsning er ukentlig data. 

```{r data}
daily_BTC <- read_csv("data/BTC_USD Bitfinex Historical Data.csv") #kan oppdateres

daily_BTC$Date <- mdy(daily_BTC$Date)

daily_BTC <- daily_BTC %>%
  select(Date, Price) %>%
  rename(Dato = "Date", BTC_usd = "Price")

day_mean <- daily_BTC %>%
  group_by(day = weekdays(Dato)) %>%
  summarise(meanBTC = mean(BTC_usd))

  ggplot(day_mean, aes(x=factor(day), y=meanBTC)) +
  geom_bar(stat = "identity")

BTC2017 <- daily_BTC %>%
  filter(Dato > "2017-01-01")

BTC2018 <- daily_BTC %>%
  filter(Dato >= "2018-01-01")


shanghai <- read_csv("data/Shanghai Composite Historical Data.csv", 
            col_types = cols(Date = col_date(format = "%b %d, %Y"), 
                                            Price = col_number()))

daily_shanghai <- shanghai %>%
  select(Date, Price)

names(daily_shanghai) <- c("Dato", "shanghai")

#osebx <- read_excel("data/osebx.xlsx")

#daily_osebx <- osebx %>%
#  select(OSEBX, Siste) %>%
#  rename(Dato = "OSEBX", OSEBX = "Siste")
#daily_osebx$Dato <- ymd(daily_osebx$Dato)

###joiner data

ukedager <- daily_shanghai %>%
  inner_join(daily_BTC, by = "Dato")

ukedager_years <- ukedager %>%
  mutate(year = substr((Dato), start = 1, stop = 4))

ukedager_years$year <- as.factor(ukedager_years$year)

ggplot(ukedager_years, aes(x = BTC_usd, y = shanghai, col = year)) +
  geom_point()

ukedager

ukedager2017 <- daily_shanghai %>%
  inner_join(BTC2017, by = "Dato")

ukedager2018 <- daily_shanghai %>%
  inner_join(BTC2018, by = "Dato") 

```

```{r volum}
btc_web <- read_html("https://coinmarketcap.com/currencies/bitcoin/historical-data/?start=20130428&end=20181208")
btc_web <- btc_web %>% html_nodes("table") 
btc_web <- btc_web %>% html_table(fill = TRUE)

BTC_vol <- btc_web[[1]] %>%
  select(Date, Volume) %>%
  rename(Dato = "Date", BTC = "Volume")

BTC_vol$Dato <- BTC_vol$Dato %>%
  str_replace_all(","," ") %>%
  mdy(.)

BTC_vol$BTC <- BTC_vol$BTC %>%
  str_replace_all(",", "") %>%
  as.numeric()

summary(BTC_vol)

#shanghai_vol <- shanghai %>%
#  select(shanghai, 'Offisielt omsatt (NOK)') %>%
#  rename(Dato = "shanghai", shanghai = "Offisielt omsatt (NOK)")
#shanghai_vol$Dato <- ymd(daily_shanghai$Dato)
#shanghai_vol$shanghai <- as.numeric(shanghai_vol$shanghai)

#vol_df <- BTC_vol %>%
#  filter(!is.na(BTC)) %>%
#  inner_join(shanghai_vol, by = "Dato")%>%
#  gather(key = "exchange", value = "volume", -Dato)

#ggplot(vol_df, aes(x=Dato, y=volume, col = exchange)) +
#  geom_line()

```


```{r lm}
fit <- lm(shanghai~BTC_usd, data = ukedager)
summary(fit)
plotModel(fit)

#residual standard error?
#R-squared = r^2
```

Vi ser at en lineær modell ikke passer for tidsintervallet. Kanskje prøve en ikke lineær-modell eller ikke-lineær funksjon. shanghai mot log(BTC) gir en mye bedre fit. Vi kan undersøke det lineære forholdet mellom shanghai og logaritmeverdiene av bitcoin. I enkelte ggplot-grafer er en svært lav alpha benyttet for å vise den ekstreme overplottingen for lave verdier av BTC.  

```{r ,warning = TRUE}

ukedager_log <- ukedager %>%
  filter(BTC_usd>0) %>% #, Dato < "2018-01-01") %>%
  mutate(BTC_log = log(BTC_usd))

lm_logfit <- lm(shanghai~BTC_log, data = ukedager_log)
summary(lm_logfit)
plotModel(lm_logfit)

ggplot(ukedager, aes(x=BTC_usd, y=shanghai)) +
  geom_point()

ggplot(ukedager, aes(x=BTC_usd, y=shanghai)) +
  geom_point(alpha = 0.1)

ggplot(ukedager_log, aes(x=BTC_log, y=shanghai)) +
  geom_point(alpha = 0.3) + 
  geom_smooth(method = "lm", se = FALSE, col = "red") +
  labs(x = "log(BTC)")

logfit <- lm(shanghai~log(BTC_usd), data = ukedager_log)
summary(logfit)
plotModel(logfit)

```



```{r lm2}
fit2 <- lm(shanghai~BTC_usd, data = ukedager2017)
summary(fit2)
plotModel(fit2)


fit18 <- lm(shanghai~BTC_usd, data = ukedager2018)
summary(fit18)
plotModel(fit18)
```


Vi er interessert i å se hvordan korrelasjonen har utviklet seg over tid. Vi har benyttet 100 dagers glidende korrelasjon. Korrelasjonen på 100 dager flyttes mot høyre. Enhver observasjonen er et resultat av de siste 100 dagene. 


```{r , echo = TRUE}
rolling_cor <- ukedager %>% 
  mutate(cor_100 = slide2(shanghai, BTC_usd, cor, .size = 100, .align = "right")) %>% 
  unnest() %>%
  na.omit()

mean.cor <- cor(rolling_cor$shanghai,rolling_cor$BTC_usd)
mean.100.cor <- mean(rolling_cor$cor_100)
mean.cor
mean.100.cor

ggplot(data = rolling_cor) + geom_line(aes(x = Dato, y = cor_100)) + 
  geom_hline(yintercept=mean.cor, linetype="dashed", color = "red", size=1) +
  geom_hline(yintercept=mean.100.cor, linetype="dashed", color = "blue", size=1)
```

Korrelasjonen varierer sterkt. Den gjennomsnittlige korrelasjonen er høyere enn gjennomsnittet av den 100-dagers glidende korrelasjonen. Hva betyr dette?

```{r}

BTC_returns <- daily_BTC %>%
  filter(BTC_usd > 0) %>%
  tq_transmute(mutate_fun = periodReturn, period = "yearly", type = "arithmetic")

ggplot(BTC_returns, aes(x=Dato, y=yearly.returns)) +
  geom_line()
```



Konklusjon: Hovedindeksen og bitcoin-prisen er positivt korrelerte. Det vil si at når BTC øker, øker også shanghai. Modellen sier ikke noe om årsak og effekt. 

##Bitcoin og det kinesiske aksjemarkedet.

Vi benytter samme data for BTC og samme metode for å slå sammen datasett. 

```{r sp500}
sp500 <- read_csv("data/^GSPC.csv")
#S&P 500 er en indeks som består av de 500 største selskapene på NYSE (?)

sp500 <- sp500 %>%  
  select(Date, Close) %>%
  rename(Dato = "Date", sp500 = "Close")

ukedager <- ukedager %>%
  inner_join(sp500, by = "Dato")

ukedager2017 <- ukedager2017 %>%
  inner_join(sp500, by = "Dato")

ukedager2018 <- ukedager2018 %>%
  inner_join(sp500, by = "Dato")

ukedager_long <- ukedager%>%
  gather(index, verdi, -Dato, -BTC_usd)

ukedager_long


fit22 <- lm(sp500~BTC_usd, data = ukedager)
summary(fit22)
plotModel(fit22)

ukedager_log <- ukedager %>%
  filter(BTC_usd>0) %>% #, Dato < "2018-01-01") %>%
  mutate(BTC_log = log(BTC_usd))

lm_logfit22 <- lm(sp500~BTC_log, data = ukedager_log)
summary(lm_logfit22)
plotModel(lm_logfit22)

#residual standard error

ggplot(ukedager, aes(x=BTC_usd, y=sp500)) +
  geom_point()

ggplot(ukedager, aes(x=BTC_usd, y=sp500)) +
  geom_point(alpha = 0.1)

ggplot(ukedager_log, aes(x=BTC_log, y=sp500)) +
  geom_point(alpha = 0.3) + 
  geom_smooth(method = "lm", se = FALSE, col = "red") +
  labs(x = "log(BTC)")

logfit22 <- lm(sp500~log(BTC_usd), data = ukedager_log)
summary(logfit22)
plotModel(logfit22)


fit22 <- lm(sp500~BTC_usd, data = ukedager2017)
summary(fit22)
plotModel(fit22)


fit182 <- lm(sp500~BTC_usd, data = ukedager2018)
summary(fit182)
plotModel(fit182)


ggplot(ukedager_long, aes(x=verdi, y = BTC_usd)) +
  geom_point() +
  facet_wrap(~index)

ggplot(ukedager_long, aes(x=verdi, y = BTC_usd, col = index)) +
  geom_point()

#logaritmisk scale på bitcoin
ggplot(ukedager_long, aes(x=verdi, y = BTC_usd, col = index)) +
  geom_point() +
  scale_y_log10()

```

Glidende korrelasjon BTC og Shanghai

```{r}

rolling_cor_sp <- ukedager %>% 
  mutate(sp_cor_100 = slide2(sp500, BTC_usd, cor, .size = 100, .align = "right")) %>% 
  unnest() %>%
  na.omit()

mean.cor.sp <- cor(rolling_cor_sp$sp500,rolling_cor_sp$BTC_usd)
mean.100.cor.sp <- mean(rolling_cor_sp$sp_cor_100)

ggplot(data = rolling_cor_sp) + geom_line(aes(x = Dato, y = sp_cor_100)) + 
  geom_hline(yintercept=mean.cor.sp, linetype="dashed", color = "red", size=1) +
  geom_hline(yintercept=mean.100.cor.sp, linetype="dashed", color = "blue", size=1)


```

